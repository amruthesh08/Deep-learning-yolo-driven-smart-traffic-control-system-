import cv2
import RPi.GPIO as GPIO
from time import sleep
import numpy as np

# GPIO Configuration for 8-bit mode
LED_RED_1, LED_GREEN_1 = 2, 3
LED_RED_2, LED_GREEN_2 = 4, 27
RS, RW, E = 16, 12, 1
DB0, DB1, DB2, DB3 = 7, 8, 25, 24  # New pins for DB0-DB3
DB4, DB5, DB6, DB7 = 23, 18, 15, 14  # Existing pins

# Combine all Data Pins
DATA_PINS = [DB0, DB1, DB2, DB3, DB4, DB5, DB6, DB7]

GPIO.setmode(GPIO.BCM)
GPIO.setup([LED_RED_1, LED_GREEN_1, LED_RED_2, LED_GREEN_2], GPIO.OUT)
GPIO.setup([RS, RW, E] + DATA_PINS, GPIO.OUT)

# Function to send command/data to LCD in 8-bit mode
def lcd_command(data, rs=0):
    GPIO.output(RS, rs)  # RS = 0 (command) or 1 (data)
    for pin, val in zip(DATA_PINS, [(data >> i) & 1 for i in range(8)]):
        GPIO.output(pin, val)  # Send all 8 bits
    GPIO.output(E, GPIO.HIGH)
    sleep(0.001)
    GPIO.output(E, GPIO.LOW)

# Initialize LCD for 8-bit mode
def lcd_init():
    sleep(0.02)  # Wait for LCD to power up
    lcd_command(0x38)  # Function Set: 8-bit, 2 lines, 5x8 dots
    lcd_command(0x0C)  # Display ON, Cursor OFF
    lcd_command(0x06)  # Entry mode: Increment cursor
    lcd_command(0x01)  # Clear display
    sleep(0.002)

# Function to write text on the LCD
def lcd_write(text):
    lcd_command(0x01)  # Clear display
    for char in text:
        lcd_command(ord(char), rs=1)

lcd_init()

# Load YOLO Tiny v4
net = cv2.dnn.readNet("yolov4-tiny.weights", "yolov4-tiny.cfg")
with open("coco.names", "r") as f:
    classes = [line.strip() for line in f.readlines()]
layer_names = net.getUnconnectedOutLayersNames()

# Process Video Streams
def process_camera(camera_source, camera_id):
    cap = cv2.VideoCapture(camera_source)
    if not cap.isOpened():
        print(f"Camera {camera_id} not available.")
        return 0

    ret, frame = cap.read()
    if not ret or frame is None:
        print(f"No frame captured from Camera {camera_id}.")
        cap.release()
        return 0

    # Display the camera preview
    cv2.imshow(f'Camera {camera_id} Preview', cv2.resize(frame, (600, 400)))

    # YOLO detection
    blob = cv2.dnn.blobFromImage(frame, 1/255.0, (416, 416), swapRB=True, crop=False)
    net.setInput(blob)
    detections = net.forward(layer_names)

    count = 0
    for output in detections:
        for detection in output:
            scores = detection[5:]
            class_id = np.argmax(scores)
            if scores[class_id] > 0.5 and classes[class_id] in ["car", "truck", "bus", "motorbike"]:
                count += 1

    cap.release()
    return count

# Main Program
try:
    while True:
        traffic_count_1 = process_camera(0, "Camera 1")  # Local Camera
        traffic_count_2 = process_camera('http://192.168.198.2:8080/video', "Camera 2")  # Server Camera

        print(f"Camera 1 Traffic: {traffic_count_1}, Camera 2 Traffic: {traffic_count_2}")

        if traffic_count_1 > traffic_count_2:
            # Road 1 has higher traffic
            GPIO.output([LED_RED_1, LED_GREEN_2], GPIO.HIGH)
            GPIO.output([LED_GREEN_1, LED_RED_2], GPIO.LOW)
            lcd_write("Road 1: High Traffic")
        elif traffic_count_2 > traffic_count_1:
            # Road 2 has higher traffic
            GPIO.output([LED_RED_2, LED_GREEN_1], GPIO.HIGH)
            GPIO.output([LED_GREEN_2, LED_RED_1], GPIO.LOW)
            lcd_write("Road 2: High Traffic")
        else:
            # Equal traffic
            GPIO.output([LED_GREEN_1, LED_GREEN_2], GPIO.HIGH)
            GPIO.output([LED_RED_1, LED_RED_2], GPIO.LOW)
            lcd_write("Traffic Equal")
            sleep(2)  # Show green for both for 2 seconds

            # Alternate green lights
            GPIO.output([LED_GREEN_1, LED_RED_2], GPIO.HIGH)
            GPIO.output([LED_RED_1, LED_GREEN_2], GPIO.LOW)
            lcd_write("Road 1: Green, Road 2: Red")
            sleep(2)

            GPIO.output([LED_GREEN_2, LED_RED_1], GPIO.HIGH)
            GPIO.output([LED_RED_2, LED_GREEN_1], GPIO.LOW)
            lcd_write("Road 2: Green, Road 1: Red")
            sleep(2)

        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

except KeyboardInterrupt:
    print("Exiting...")
    GPIO.cleanup()
finally:
    cv2.destroyAllWindows()
